        /*http://www.cnblogs.com/sutengcn/archive/2008/05/19/1202751.html
         * 
         * 
         * (1)CLR使用了一种叫字符串驻留的技术，对于
            string   str1="abc";
            string   str2="abc";
            当CLR初始化时，会创建一个内部的散列表,其中的键为字符串，值为指向托管堆中字符串的引用。刚开始,散列表为空，JIT编译器编译方法时，会在散列表中查找每一个文本常量字符串，首先会查找"abc"字符串，并且因为没有找到，编译器会在托管堆中构造一个新的指向"abc"的String对象引用，然后将"abc"字符串和指向该对象的引用添加到散列表中。
　　            接着，在散列表中查找第二个"abc"，这一次由于找到了该字符串，所以编译器不会执行任何操作，代码中再没有其它的文本常量字符串，编译器的任务完成，代码开始执行。执行时，CLR发现第一个语句需要一个"abc"字符串引用，于是，CLR会在内部的散列表中查找"abc"，并且会找到，这样指向先前创建的String对象的引用就被保存在变量s1中，执行第二条语句时，CLR会再一次在散列表中查找"abc"，并且仍然会找到，指向同一个String对象的引用会被保存在变量s2中，到此s1和s2指向了同一个引用，所以System.Object.Equals(s1,s2)就会返回true了。
            (2)当使用重载操作符”=”给string对象赋值时,string的对象是引用类型,它保留在堆上,而不是堆栈上.因此,当把一个字符串赋给另一个字符串时,会得到对内存中同一个字符串的两个引用.例如,修改其中一个字符串,就会创建一个全新的string对象(注意,这个过程发生在”=”中),而另一个字符串没有改变.
         * 
         */
        //1. 值类型数组虽然分配在堆上，但数组元素依然是值类型，并没有被装箱。
        //2, 引用对象的值类型成员也随对象一起分配在堆上，同样也还是值类型，没有被装箱
		
		
		/*
 * 6，C#中值类型分配在堆栈中。
值类型：bool,byte,char,decimal,double,enum,float,int,long,sbyte,short,struct,uint,ulong,ushort.
7，C#中引用类型分配在堆中，在堆栈中创建一个指向到堆的引用，返回给声明的变量。
引用类型：class,delegate,interface,object,string
 */